* types & grammar
  1. 判断以下结果
     #+BEGIN_SRC javascript
     var s = 'abc';
     s[1] = 'B';
     
     console.log(s);
     
     string 及其包装对象 (Boxed Object) 是不可变 (immutable) 类型，因此不能改变它本身(modify in place)，所以 String 的所有方法都是返回一个新的字符串，而不会改变自身
     
     var l = new String('abc');
     l[1] = 'B';
     console.log(l);
     #+END_SRC
     // s = aBc
     // s = abc
  2. 如何逆序一个字符串？
  var reverse = function( str ){
   var stack = [];//生成一个栈
   for(var len = str.length,i=len;i>=0;i-- ){
    stack.push(str[i]);
   }
   return stack.join('');
   };

  3. 接上，为什么不能直接使用
     #+BEGIN_SRC javascript
     Array.prototype.reverse.call(str)
     #+END_SRC
     逆序字符串？
     因为会破坏数组 一般情况 不希望破坏原数组的 内容 更使用MAP之类


  4. 判断以下结果，为什么会出现这样的情况，如何做出正确的比较？
     #+BEGIN_SRC javascript
     0.1 + 0.2 === 0.3;
     0.8 - 0.6 === 0.3;
     #+END_SRC
    因为有计算的精度确实 
    可以(0.110+0.210)/10 ===0.3
    浮点数根据 IEEE 754 标准存储64 bit 双精度，能够表示 2^64 个数，而浮点数是无穷的，代表有些浮点数必会有精度的损失，0.1，0.2 表示为二进制会有精度的损失。比较时引入一个很小的数值 Number.EPSILON 容忍误差，其值为 2^-52。

   function equal (a, b) {
   return Math.abs(a - b) < Number.EPSILON
   }

  5. 如何判断一个数值为整数？
      // ES6
      Number.isInteger(num);
      // ES5
      if (!Number.isInteger) {
      Number.isInteger = function(num) {
         return typeof num == "number" && num % 1 == 0;
      };
      }

  6. 如何判断一个数值为+0？
      function isPosZero (n) {
      return n === 0 && 1 / n === Infinity
      }
  7. 以下代码中'abc'作为primitive value, 如何访问toUpperCase 方法?
     #+BEGIN_SRC javascript
     'abc'.toUpperCase();
     #+END_SRC
     cc = “abc”.toUpperCase();
  8. 判断以下结果
     #+BEGIN_SRC javascript
     Array.isArray(Array.prototype);
     #+END_SRC
      true
      true 内置对象的 prototype 都不是纯对象，比如 Date.prototype 是 Date，Set.prototype 是 Set。
  9. 判断以下结果
     #+BEGIN_SRC javascript
     Boolean(Boolean(false));
     Boolean(document.all);

     [] == '';
     [3] == 3;
     [] == false;
     42 == true;
     #+END_SRC
     true
  10. 找出以下代码问题(TDZ)
      #+BEGIN_SRC javascript
      var a = 3;
      let a;
      #+END_SRC
       第一个是 全局 所以是3
       第二个 块级作用域  在函数内是生声明了 所以是a 还是3
  11. 找出以下代码问题(TDZ)
      #+BEGIN_SRC javascript
      var b = 3;
      function foo(a = 42, b = a + b + 5) {
        // ..
      }
      
      foo();
      #+END_SRC
      // b=a+b+5 在参数b（=右边的b）的TDZ中访问b，所以会出错。而访问a却没有问题
* scope & closures

  1. var a = 2 中, Engine, ScopeEngine ：负责js的编译和执行
   Compiler： Engine的好基友，负责一些脏活累活，比如语法分析词法分析AST的生成
   Scope：Engine的另一个好基友，负责收集和维护一个有关变量（包括方法的）查询列表，并定义一个规范集合去规定在代码执行阶段的变量存取方式,
   Eng编译器碰到变量a，Compiler询问特定Scope的集合中是否存在变量a，不存在就创建一个，存在的话Compiler就忽略继续ine ：负责js的编译和执行
   Compiler将会generate code为Engine运行代码做准备，运行时刻才会执行a=2(assignment)，code engine 在执行的时候会先查看当前scope的集合中是否存在a，如果有就拿出来，没有的话继续查找(nest scope) 找到a再赋值2给它，找到顶 找不到就报错
  
  2. 判断以下结果(lexical scope)
     #+BEGIN_SRC javascript
     var scope = 'global scope';
     function checkscope() {
         var scope = 'local scope';
         function f() {
           return scope;
         }
         return f;
     }
     #+END_SRC
     local scope’

     由于 js 为词法作用域(Lexical Scope)，访问某个变量时，先在当前作用域中查找，如果查找不到则在嵌套作用域中查找，直到找到。如果找不到，则报 ReferenceError 。

  3. 判断以下结果(Hoisting)
     #+BEGIN_SRC javascript
     console.log(a);
     var a = 3;
     #+END_SRC
     undefined

  4. 判断以下结果(Function First)
     #+BEGIN_SRC javascript
     var foo = 1;
     function foo() {}
     console.log(foo);
     #+END_SRC
     函数也会有提升，所以会被赋值覆盖

  5. 判断以下结果(IIFE & Function First)
     #+BEGIN_SRC javascript
     var foo = 1;
     (function () {
       foo = 2;
       function foo (){
       }
       console.log(foo);
     })()
     console.log(foo);
     #+END_SRC
     2，1 ;

  6. 判断以下结果，如何按序输出(Closure)
     #+BEGIN_SRC javascript
     for (var i = 0; i < 10; i++) {
       setTimeout(function () {
         console.log(i);
       }, i * 1000);
     }
     #+END_SRC
     大约 1s 之后连续输出 10 个 10。因为没有块级作用域，可以把 var 改成 let，也可以给 setTimeout 包装一层 IIFE

* this & object prototypes
  1. 判断以下结果(Default Binding)
     #+BEGIN_SRC javascript
     function foo() {
       "use strict"
       console.log(this.a);
     }
     var a = 2;
     
     foo();
     #+END_SRC
     会报错，在函数的严格模式下，默认绑定其中的 this 指向 undefined

  2. 判断以下结果
     #+BEGIN_SRC javascript
     "use strict"
     var a = 2;
     console.log(this);
     #+END_SRC
     2, undefine
    在浏览器环境中 this 指向 window，而 var 声明的变量会被挂在 window 上。而 let 声明的变量不会挂在 window 上。

  3. 判断以下结果(strict mode & default binding)
     #+BEGIN_SRC javascript
     function foo() {
       console.log(this.a);
     }
     var a = 2;
     (function(){
       "use strict"
       foo();
     })();
     #+END_SRC
      2 只有存在 this 的函数中设置严格模式，this 为 undefined。因此会正常输出

  4. 判断以下结果(hard binding)
     #+BEGIN_SRC javascript
     function foo() {
       console.log(this.a);
     }
     const o1 = { a: 3 };
     const o2 = { a: 4 };

     foo.bind(o1).bind(o2)();
     #+END_SRC
     3bind 为硬绑定，第一次绑定后 this 无法再次绑定。

  5. 如何实现
     #+BEGIN_SRC javascript
     Function.prototype.bind
     Function.prototype.softBind
     #+END_SRC
     Function.prototype.fakeBind = function (obj) {
      var self = this;
      return function () {
         self.call(obj);
      }
      }

      Function.prototype.softBind = function(obj) {
      var self = this;
      return function () {
         self.call(this === window? obj : this);
      }
      };

  6. new 的过程中发生了什么, 判断以下结果(new)
     #+BEGIN_SRC javascript
     function F() {
       this.a = 3;
       return {
         a: 4
       }
     }
     const f = new F();
     console.log(f.a);
     #+END_SRC
     4
      new 的过程大致为如下几个步骤

      创建一个新的对象
      this 指向实例，并且执行函数
      如果没有显式返回，则默认返回这个实例
      因为函数最后显式返回了一个对象，所以打印为 4

  7. 什么是data descriptor 和 accessor descriptor?
      两者均通过 Object.defineProperty() 定义，有两个公有的
      configurable 设置该键是否可以删除
      enumerable 设置是否可被遍历
      数据描述符有以下键
      writable 该键是否可以更改
      value
      访问器描述符有以下键值
      set
      get 另外，也可以通过字面量的形式表示访问器描述符

  8. 如何访问一个对象的属性与如何对一个对象的属性赋值(Get & Put)?

      是否被 Proxy 拦截，如果拦截，查看拦截器的返回值，如果没拦截，继续下一步
      检查自身属性，如果没找到则继续下一步
      如果没被找到，则在原型链上查找，如果没找到，则返回 undefined
      查找过程与 Scope 查找变量很相似，只不过，对象属性找不到，返回 undefined，而变量找不到报 Reference Error
      对一个对象的属性赋值会触发 [[Put]] 操作，大致简述如下

      检查是否被 Proxy 拦截
      如果该对象属性为自身属性 (obj.hasOwnProperty(‘a’) === true)
      如果属性是访问描述符，则调用 setter 函数
      如果属性是 data descriptor，则检查 writable 是否可写
      普通属性，直接赋值
      如果该对象属性存在于原型链上
      如果属性是访问描述符，则调用 setter 函数
      如果属性是 data descriptor，则检查 writable 是否可写。如果可写，被自身属性覆盖，否则在严格模式下将会报错
      普通属性，被自身属性覆盖
      如果该对象不存在与原型链上，直接给自身属性赋值
  9. 如何遍历一个对象(iterator)?
      给对象设置 Symbol.iterator 属性
  10. 如何实现一个继承(Object.create & call)?
      function A () {}

      function B () {
      A.call(this)
      }

      B.prototype = Object.create(A.prototype)
      // B.prototype = new A()

  11. 如何实现 __proto__?
   Object.defineProperty(Object.prototype, '__proto__', {
    get() {
       let _thisObj = Object (this);
       return Object.getPrototypeOf(_thisObj);
   },
   set(proto) {
       if (this === undefined || this === null) {
           throw new TypeError();
       }
       if (!isObject(this)) {
           return undefined;
       }
       if (!isObject(proto)) {
           return undefined;
       }
       let status = Reflect.setPrototypeOf(this, proto);
       if(!status) {
           throw new TypeError();
       }
   },
});
function isObject(value) {
    return Object(value) === value;
}
  12. 如何实现Object.create?
   Object.create = function (o) {
   function F() {}
   F.prototype = o;
   return new F();
   }
